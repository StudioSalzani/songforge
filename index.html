<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Songforge — The Book of Maledictions</title>
  <meta name="description" content="A ritual of enforced creative constraints for music composition." />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400&family=IBM+Plex+Mono:wght@400&family=Inter:wght@400;500&display=swap" rel="stylesheet" />
  <style>
/* ═══════════════════════════════════════════════════════
   SONGFORGE — The Book of Maledictions
   Master Stylesheet
   ═══════════════════════════════════════════════════════ */

/* ─── Custom Properties ──────────────────────────────── */
:root {
  --bg:              #0a0a0a;
  --bg-raised:       #111111;
  --bg-card:         #141414;
  --text-primary:    #e8e8e8;
  --text-secondary:  #6b6b6b;
  --text-muted:      #3d3d3d;
  --border:          #222222;
  --border-active:   #444444;
  --accent:          #c8b896;
  --accent-dim:      #6b5e3f;
  --danger:          #8b3a3a;
  --danger-dim:      #5a2525;

  --font-title:      'Cormorant Garamond', 'Palatino Linotype', Palatino, serif;
  --font-body:       'Inter', system-ui, sans-serif;
  --font-mono:       'IBM Plex Mono', 'Courier New', monospace;

  --transition:      200ms ease;
}

/* ─── Reset & Base ───────────────────────────────────── */
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  height: 100%;
  overflow: hidden; /* ritual screens fill viewport; no scrolling on body */
}

body {
  background: var(--bg);
  color: var(--text-primary);
  font-family: var(--font-body);
  font-size: 15px;
  line-height: 1.6;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#app {
  width: 100%;
  height: 100%;
}

/* ─── Screen Base ────────────────────────────────────── */
.screen {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 40px 24px;
  animation: fadeIn 400ms ease forwards;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to   { opacity: 1; }
}

/* ─── Typography ─────────────────────────────────────── */
.title {
  font-family: var(--font-title);
  font-size: clamp(2.4rem, 6vw, 4rem);
  font-weight: 300;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: var(--text-primary);
  line-height: 1.1;
}

.subtitle {
  font-family: var(--font-title);
  font-size: clamp(0.85rem, 2vw, 1rem);
  font-weight: 300;
  letter-spacing: 0.35em;
  text-transform: uppercase;
  color: var(--text-secondary);
  margin-top: 10px;
}

.divider {
  width: 32px;
  height: 1px;
  background: var(--border-active);
  margin: 36px auto;
}

/* ─── Buttons ────────────────────────────────────────── */
.btn-ritual {
  display: block;
  width: 100%;
  max-width: 280px;
  margin: 36px auto 0;
  padding: 14px 24px;
  background: transparent;
  border: 1px solid var(--border-active);
  color: var(--text-primary);
  font-family: var(--font-body);
  font-size: 0.75rem;
  letter-spacing: 0.25em;
  text-transform: uppercase;
  cursor: pointer;
  transition: background var(--transition), border-color var(--transition), color var(--transition);
}

.btn-ritual:hover {
  background: var(--bg-raised);
  border-color: var(--accent-dim);
  color: var(--accent);
}

.btn-ritual:active {
  background: var(--bg-card);
}

/* Chaos variant — heavier border to signal weight */
.btn-chaos {
  border-color: var(--danger-dim);
}
.btn-chaos:hover {
  border-color: var(--danger);
  color: var(--danger);
  background: rgba(139, 58, 58, 0.06);
}

/* ═══════════════════════════════════════════════════════
   SCREEN: ONBOARDING
   ═══════════════════════════════════════════════════════ */

.onboarding-inner {
  text-align: center;
  max-width: 480px;
  width: 100%;
}

.warning-block {
  text-align: left;
  border-left: 1px solid var(--border);
  padding-left: 20px;
  margin: 0 auto;
  max-width: 400px;
}

.warning-header {
  font-family: var(--font-mono);
  font-size: 0.7rem;
  letter-spacing: 0.2em;
  text-transform: uppercase;
  color: var(--accent-dim);
  margin-bottom: 12px;
}

.warning-text {
  font-size: 0.9rem;
  color: var(--text-secondary);
  line-height: 1.8;
}

/* ═══════════════════════════════════════════════════════
   SCREEN: DRAW (Structure / Constraint / Chaos)
   ═══════════════════════════════════════════════════════ */

.draw-inner {
  text-align: center;
  max-width: 480px;
  width: 100%;
}

.draw-step {
  display: flex;
  align-items: baseline;
  justify-content: center;
  gap: 12px;
  margin-bottom: 32px;
}

.step-number {
  font-family: var(--font-title);
  font-size: 1.6rem;
  font-weight: 300;
  color: var(--text-muted);
  letter-spacing: 0.1em;
}

.step-label {
  font-family: var(--font-mono);
  font-size: 0.7rem;
  letter-spacing: 0.2em;
  text-transform: uppercase;
  color: var(--text-secondary);
}

/* Constraint card */
.constraint-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  padding: 32px 28px;
  text-align: left;
  animation: cardReveal 350ms cubic-bezier(0.22, 1, 0.36, 1) forwards;
  opacity: 0;
  transform: translateY(6px);
}

@keyframes cardReveal {
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.card-title {
  font-family: var(--font-title);
  font-size: 1.5rem;
  font-weight: 400;
  color: var(--text-primary);
  margin-bottom: 12px;
  letter-spacing: 0.02em;
}

.card-desc {
  font-size: 0.88rem;
  color: var(--text-secondary);
  line-height: 1.75;
}

/* Chaos variant */
.card-chaos {
  border-color: var(--danger-dim);
}

.chaos-warning {
  font-family: var(--font-mono);
  font-size: 0.68rem;
  letter-spacing: 0.18em;
  text-transform: uppercase;
  color: var(--danger);
  margin-bottom: 20px;
}

/* ═══════════════════════════════════════════════════════
   SCREEN: CHOICE (Rhythm vs Texture)
   ═══════════════════════════════════════════════════════ */

.choice-inner {
  text-align: center;
  max-width: 480px;
  width: 100%;
}

.choice-buttons {
  display: flex;
  gap: 16px;
  justify-content: center;
  margin-top: 8px;
}

.btn-choice {
  flex: 1;
  max-width: 200px;
  padding: 28px 20px;
  background: var(--bg-card);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  font-family: var(--font-mono);
  font-size: 0.72rem;
  letter-spacing: 0.22em;
  text-transform: uppercase;
  cursor: pointer;
  transition: border-color var(--transition), color var(--transition), background var(--transition);
}

.btn-choice:hover {
  border-color: var(--accent-dim);
  color: var(--accent);
  background: rgba(200, 184, 150, 0.04);
}

.btn-choice:active {
  background: rgba(200, 184, 150, 0.08);
}

/* ═══════════════════════════════════════════════════════
   SCREEN: RECAP
   ═══════════════════════════════════════════════════════ */

.recap-inner {
  text-align: center;
  max-width: 560px;
  width: 100%;
  max-height: 100%;
  overflow-y: auto;
  padding: 20px 0;
}

.recap-header {
  font-family: var(--font-title);
  font-size: 1.3rem;
  font-weight: 300;
  letter-spacing: 0.15em;
  text-transform: uppercase;
  color: var(--text-secondary);
  margin-bottom: 28px;
}

.recap-cards {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.recap-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  padding: 20px 24px;
  text-align: left;
}

.recap-card-label {
  font-family: var(--font-mono);
  font-size: 0.65rem;
  letter-spacing: 0.2em;
  text-transform: uppercase;
  color: var(--text-muted);
  display: block;
  margin-bottom: 6px;
}

.recap-card-title {
  font-family: var(--font-title);
  font-size: 1.15rem;
  font-weight: 400;
  color: var(--text-primary);
  margin-bottom: 4px;
}

.recap-card-desc {
  font-size: 0.82rem;
  color: var(--text-secondary);
  line-height: 1.6;
}

.recap-card-chaos {
  border-color: var(--danger-dim);
}

/* ═══════════════════════════════════════════════════════
   SCREEN: TIMER
   ═══════════════════════════════════════════════════════ */

.timer-inner {
  text-align: center;
}

.timer-display {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.timer-time {
  font-family: var(--font-title);
  font-size: clamp(4rem, 14vw, 9rem);
  font-weight: 300;
  letter-spacing: -0.02em;
  color: var(--text-primary);
  line-height: 1;
  /* Tabular figures for stable width */
  font-variant-numeric: tabular-nums;
}

.timer-label {
  font-family: var(--font-mono);
  font-size: 0.68rem;
  letter-spacing: 0.25em;
  text-transform: uppercase;
  color: var(--text-muted);
}

/* Pulse the label subtly */
.phase-timer .timer-label {
  animation: pulse 4s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 0.4; }
  50%      { opacity: 0.7; }
}

/* ═══════════════════════════════════════════════════════
   SCREEN: END
   ═══════════════════════════════════════════════════════ */

.screen-end {
  overflow-y: auto;
  align-items: flex-start;
  padding-top: 60px;
  padding-bottom: 60px;
}

.end-inner {
  max-width: 520px;
  width: 100%;
  text-align: center;
}

.end-header {
  font-family: var(--font-title);
  font-size: 1.4rem;
  font-weight: 300;
  letter-spacing: 0.1em;
  color: var(--text-secondary);
  margin-bottom: 32px;
}

/* Session log */
.session-log {
  text-align: left;
  margin-bottom: 36px;
}

.session-log pre {
  font-family: var(--font-mono);
  font-size: 0.72rem;
  line-height: 1.9;
  color: var(--text-secondary);
  white-space: pre-wrap;
  word-break: break-word;
}

/* Friction scale */
.friction-block {
  margin-bottom: 32px;
}

.friction-label {
  font-size: 0.85rem;
  color: var(--text-secondary);
  margin-bottom: 4px;
}

.friction-sublabel {
  font-family: var(--font-mono);
  font-size: 0.68rem;
  color: var(--text-muted);
  letter-spacing: 0.1em;
  margin-bottom: 16px;
}

.friction-scale {
  display: flex;
  gap: 6px;
  justify-content: center;
  flex-wrap: wrap;
}

.friction-btn {
  width: 38px;
  height: 38px;
  background: var(--bg-card);
  border: 1px solid var(--border);
  color: var(--text-muted);
  font-family: var(--font-mono);
  font-size: 0.78rem;
  cursor: pointer;
  transition: border-color var(--transition), color var(--transition), background var(--transition);
}

.friction-btn:hover {
  border-color: var(--border-active);
  color: var(--text-secondary);
}

.friction-btn.selected {
  border-color: var(--accent-dim);
  color: var(--accent);
  background: rgba(200, 184, 150, 0.08);
}

/* Note input */
.note-block {
  margin-bottom: 8px;
}

.note-label {
  display: block;
  font-size: 0.82rem;
  color: var(--text-secondary);
  margin-bottom: 10px;
}

.note-input {
  width: 100%;
  padding: 12px 16px;
  background: var(--bg-card);
  border: 1px solid var(--border);
  color: var(--text-primary);
  font-family: var(--font-body);
  font-size: 0.88rem;
  outline: none;
  transition: border-color var(--transition);
}

.note-input:focus {
  border-color: var(--border-active);
}

.note-input::placeholder {
  color: var(--text-muted);
}

/* Share feedback */
.share-feedback {
  font-family: var(--font-mono);
  font-size: 0.7rem;
  color: var(--accent-dim);
  letter-spacing: 0.1em;
  margin-top: 12px;
  opacity: 0;
  transition: opacity 300ms ease;
}

.share-feedback.visible {
  opacity: 1;
}

/* ─── Scrollbar (subtle, for recap/end overflow) ───── */
::-webkit-scrollbar {
  width: 4px;
}
::-webkit-scrollbar-track {
  background: transparent;
}
::-webkit-scrollbar-thumb {
  background: var(--border);
  border-radius: 2px;
}

  </style>
</head>
<body>
  <div id="app"></div>
  <script id="data-strings" type="application/json">
{
  "app": {
    "title": "Songforge",
    "subtitle": "The Book of Maledictions"
  },
  "onboarding": {
    "warning_header": "Warning",
    "warning_text": "This is not an inspiration tool. You will be given three constraints. You cannot choose them. You cannot skip them. You cannot negotiate with them. You have sixty minutes. When the timer ends, the piece is final. There is no undo.",
    "begin_button": "BEGIN THE RITUAL"
  },
  "draw": {
    "structure_header": "I.",
    "structure_label": "Structure",
    "drawing_structure": "Drawing your structure\u2026",
    "accept_structure": "Accept",
    "choice_header": "II.",
    "choice_label": "Choose your second constraint",
    "choose_rhythm": "Rhythm",
    "choose_texture": "Texture",
    "drawing_constraint": "Drawing\u2026",
    "accept_constraint": "Accept",
    "chaos_header": "III.",
    "chaos_label": "Chaos Malediction",
    "drawing_chaos": "Drawing the malediction\u2026",
    "chaos_warning": "This cannot be skipped.",
    "accept_chaos": "I understand. Accept."
  },
  "recap": {
    "header": "Your constraints",
    "constraint_structure": "Structure",
    "constraint_rhythm": "Rhythm",
    "constraint_texture": "Texture",
    "constraint_chaos": "Chaos Malediction",
    "begin_session": "BEGIN SESSION"
  },
  "timer": {
    "label": "remaining"
  },
  "end": {
    "header": "The ritual is complete.",
    "session_log_label": "Session Log",
    "friction_label": "How difficult was this session?",
    "friction_sublabel": "Rate the friction, 1 to 10.",
    "note_label": "One sentence. Optional.",
    "note_placeholder": "\u2026",
    "share_button": "Share ritual",
    "share_copied": "Copied to clipboard.",
    "share_unsupported": "Copy manually from the session log above."
  }
}
  </script>
  <script id="data-structures" type="application/json">
[
  {
    "id": "struct_001",
    "title": "The Palindrome",
    "description": "The piece must read the same forwards and backwards in time. Whatever you build in the first half, you must deconstruct in exact reverse in the second half."
  },
  {
    "id": "struct_002",
    "title": "The Arch",
    "description": "A single continuous crescendo to the midpoint, then a single continuous diminuendo. No plateaus. No returns. Only ascent, then descent."
  },
  {
    "id": "struct_003",
    "title": "The Spiral",
    "description": "Each section repeats the material of the last, but with exactly one element removed. The piece ends with a single sustained note or silence."
  },
  {
    "id": "struct_004",
    "title": "The Monolith",
    "description": "No sections. No transitions. No development. One unbroken texture from beginning to end. Any change must be imperceptible."
  },
  {
    "id": "struct_005",
    "title": "The Fracture",
    "description": "The piece is split into exactly three movements with complete silence between them. Each movement must be shorter than the last."
  },
  {
    "id": "struct_006",
    "title": "The Loop",
    "description": "Identify one phrase, no longer than 8 bars. The entire piece is built by repeating this phrase. Variation is permitted only through layering, never alteration."
  },
  {
    "id": "struct_007",
    "title": "The Decay",
    "description": "Begin at maximum density and complexity. Remove one element every five minutes without adding anything new. End in silence."
  },
  {
    "id": "struct_008",
    "title": "The Binary",
    "description": "Two contrasting sections alternate strictly. A must follow B must follow A. No hybrid zones. No gradual transitions."
  },
  {
    "id": "struct_009",
    "title": "The Seed",
    "description": "The opening four bars contain all material that will exist in the piece. Everything after is derived solely from what appears in those bars."
  },
  {
    "id": "struct_010",
    "title": "The Countdown",
    "description": "Divide the session into ten equal segments. Each segment must contain exactly one fewer active voice or instrument than the one before it."
  }
]
  </script>
  <script id="data-rhythms" type="application/json">
[
  {
    "id": "rhythm_001",
    "title": "The Odd Meter",
    "description": "The entire piece must be written in a single odd meter of your choice (5, 7, 9, 11, or 13). No metric modulation. No feel-based liberties."
  },
  {
    "id": "rhythm_002",
    "title": "The Pulse Shift",
    "description": "Choose one tempo. Every 90 seconds, the pulse must shift to a subdivision that has not been used before. You have exactly six subdivisions available."
  },
  {
    "id": "rhythm_003",
    "title": "The Polyrhythm Lock",
    "description": "Two rhythmic layers must be present at all times. They must never align on the same beat after the opening downbeat."
  },
  {
    "id": "rhythm_004",
    "title": "The Silence Tax",
    "description": "For every 10 seconds of sound, you owe 3 seconds of complete silence. The debt must be paid before the next phrase begins."
  },
  {
    "id": "rhythm_005",
    "title": "The Isorhythm",
    "description": "Write a single rhythmic pattern of exactly 13 beats. Every melodic or harmonic event in the piece must fall on a beat of this pattern. It repeats without variation."
  },
  {
    "id": "rhythm_006",
    "title": "The Metric Cage",
    "description": "The piece alternates strictly between 3/4 and 7/8. No bar may use any other meter. No transitional bars."
  },
  {
    "id": "rhythm_007",
    "title": "The Diminishing Beat",
    "description": "Begin at 140 BPM. Every two minutes, the tempo drops by exactly 15 BPM. Do not round. Do not compensate. Let the piece slow itself into stillness."
  },
  {
    "id": "rhythm_008",
    "title": "The Off-Grid",
    "description": "No event may land on a strong beat. Every attack must be syncopated. If it falls on beat 1, it is wrong."
  }
]
  </script>
  <script id="data-textures" type="application/json">
[
  {
    "id": "texture_001",
    "title": "The Single Voice",
    "description": "One monophonic line. No chords, no harmony, no layering, no effects. One note at a time, from start to finish."
  },
  {
    "id": "texture_002",
    "title": "The Dense Swarm",
    "description": "A minimum of six simultaneous voices must be present at all times. If any voice drops out, another must already be sounding before the silence completes."
  },
  {
    "id": "texture_003",
    "title": "The Drone",
    "description": "One sustained note or chord must sound continuously for the entire piece. Everything else is built on top of it. It never changes pitch."
  },
  {
    "id": "texture_004",
    "title": "The Pointillism",
    "description": "No note longer than a quarter note. Every sound is a single, isolated event. Silence exists between every attack."
  },
  {
    "id": "texture_005",
    "title": "The Heterophony",
    "description": "All voices must play the same melody, but each at a different tempo. They must begin and end at the same time."
  },
  {
    "id": "texture_006",
    "title": "The Raw Tone",
    "description": "Only one timbre is permitted for the duration. No filtering, no modulation, no distortion, no reverb. One instrument or one synthesis type, unaltered."
  },
  {
    "id": "texture_007",
    "title": "The Cluster",
    "description": "All harmony must be constructed from clusters of adjacent semitones. No interval wider than a minor third may exist between any two simultaneous notes."
  },
  {
    "id": "texture_008",
    "title": "The Mirror",
    "description": "Split the ensemble into two groups. Group B must mirror Group A in real time \u2014 every attack reflected, every rest doubled. They are inseparable."
  }
]
  </script>
  <script id="data-chaos" type="application/json">
[
  {
    "id": "chaos_001",
    "title": "The Corruption",
    "description": "At the 30-minute mark, destroy one third of your existing material. Do not rebuild it. Continue composing with what remains."
  },
  {
    "id": "chaos_002",
    "title": "The Foreign Body",
    "description": "At some point in the piece, you must introduce a single element that belongs to a completely different genre. It must not be resolved or explained by the surrounding music."
  },
  {
    "id": "chaos_003",
    "title": "The Stranger's Hand",
    "description": "At the 20-minute mark, stop. Write down your next intended move. Then do the opposite."
  },
  {
    "id": "chaos_004",
    "title": "The Erasure",
    "description": "You may not use any pitch or interval that appears in the first 60 seconds of the piece after the first 60 seconds have passed."
  },
  {
    "id": "chaos_005",
    "title": "The Saboteur",
    "description": "Halfway through the session, introduce a repeating element that actively contradicts the Structure constraint. It must persist until the end."
  },
  {
    "id": "chaos_006",
    "title": "The Confession",
    "description": "Embed a personal sound \u2014 a recording of your voice, a room you know, an object you own \u2014 somewhere in the piece. It must be audible. It cannot be processed beyond recognition."
  },
  {
    "id": "chaos_007",
    "title": "The Inversion",
    "description": "At the halfway point, invert the dynamic trajectory of everything you have written so far. Loud becomes quiet. Quiet becomes loud. The shape flips."
  },
  {
    "id": "chaos_008",
    "title": "The Borrowed Time",
    "description": "You must quote \u2014 verbatim, unaltered \u2014 at least four bars from a piece of music you did not write. It must be woven into the structure as if it belongs."
  },
  {
    "id": "chaos_009",
    "title": "The Blind Spot",
    "description": "Remove one sense from your compositional process. If you are notating, do not listen. If you are listening, do not look at what you are writing. Maintain this for the final 20 minutes."
  },
  {
    "id": "chaos_010",
    "title": "The Severance",
    "description": "At the 40-minute mark, end the piece. Whatever exists at that moment is the final version. The remaining 20 minutes are silence. You may not add to it."
  },
  {
    "id": "chaos_011",
    "title": "The Weight",
    "description": "The piece must contain at least one passage of sustained, deliberate discomfort. Not tension that resolves \u2014 discomfort that persists. The listener must not be able to look away."
  },
  {
    "id": "chaos_012",
    "title": "The Collaborator",
    "description": "Contact one other person. Give them a single constraint \u2014 not one of yours. Incorporate their response into the piece without explanation."
  }
]
  </script>
  <script>
/**
 * state.js — Songforge State Manager
 * 
 * Single source of truth for the entire ritual.
 * No DOM references. No rendering logic.
 * Exports a state object and pure functions to mutate it.
 * Subscribers are notified on every change.
 */

const State = (() => {
  // --- Internal state ---
  let _state = {
    phase: 'onboarding',      // onboarding | draw_structure | choice | draw_constraint | draw_chaos | recap | timer | end
    structure: null,           // { id, title, description }
    constraintType: null,      // 'rhythm' | 'texture'
    constraint: null,          // { id, title, description }
    chaos: null,               // { id, title, description }
    timer: {
      total: 3600,             // 60 minutes in seconds
      remaining: 3600,
      intervalId: null
    },
    session: {
      startedAt: null,
      endedAt: null,
      frictionRating: null,
      note: ''
    },
    strings: {},               // loaded text strings
    data: {                    // loaded constraint pools
      structures: [],
      rhythms: [],
      textures: [],
      chaos: []
    }
  };

  const _subscribers = [];

  // --- Subscriber pattern ---
  function subscribe(fn) {
    _subscribers.push(fn);
  }

  function _notify() {
    _subscribers.forEach(fn => fn(_state));
  }

  // --- Getters ---
  function getState() {
    return { ..._state };
  }

  function get(key) {
    return _state[key];
  }

  // --- Setters (controlled mutations) ---
  function setPhase(phase) {
    _state.phase = phase;
    
    // Stop the timer if we're entering the end phase
    if (phase === 'end' && _state.timer.intervalId) {
      clearInterval(_state.timer.intervalId);
      _state.timer.intervalId = null;
      if (!_state.session.endedAt) {
        _state.session.endedAt = Date.now();
      }
    }
    
    _notify();
  }

  function setStructure(constraint) {
    _state.structure = constraint;
    _notify();
  }

  function setConstraintType(type) {
    _state.constraintType = type;
    _notify();
  }

  function setConstraint(constraint) {
    _state.constraint = constraint;
    _notify();
  }

  function setChaos(constraint) {
    _state.chaos = constraint;
    _notify();
  }

  function setStrings(strings) {
    _state.strings = strings;
  }

  function setData(key, data) {
    _state.data[key] = data;
  }

  function setFrictionRating(rating) {
    _state.session.frictionRating = rating;
    // Don't notify - this is just data, not a phase change
  }

  function setNote(note) {
    _state.session.note = note;
  }

  function resetConstraints() {
    _state.structure = null;
    _state.constraint = null;
    _state.chaos = null;
    _state.constraintType = null;
  }

  // --- Timer ---
  function startTimer() {
    _state.session.startedAt = Date.now();
    _state.timer.remaining = _state.timer.total;
    _state.phase = 'timer';

    _state.timer.intervalId = setInterval(() => {
      _state.timer.remaining -= 1;

      if (_state.timer.remaining <= 0) {
        clearInterval(_state.timer.intervalId);
        _state.timer.intervalId = null;
        _state.timer.remaining = 0;
        _state.session.endedAt = Date.now();
        _state.phase = 'end';
      }

      _notify();
    }, 1000);
  }

  function getTimeRemaining() {
    return _state.timer.remaining;
  }

  // --- Session persistence ---
  function saveSession() {
    const session = {
      date: _state.session.startedAt ? new Date(_state.session.startedAt).toISOString() : null,
      structure: _state.structure,
      constraintType: _state.constraintType,
      constraint: _state.constraint,
      chaos: _state.chaos,
      frictionRating: _state.session.frictionRating,
      note: _state.session.note
    };

    let history = [];
    try {
      history = JSON.parse(localStorage.getItem('songforge_history') || '[]');
    } catch (e) { /* ignore corrupt data */ }

    history.push(session);
    localStorage.setItem('songforge_history', JSON.stringify(history));
  }

  function getHistory() {
    try {
      return JSON.parse(localStorage.getItem('songforge_history') || '[]');
    } catch (e) {
      return [];
    }
  }

  return {
    subscribe,
    getState,
    get,
    setPhase,
    setStructure,
    setConstraintType,
    setConstraint,
    setChaos,
    setStrings,
    setData,
    setFrictionRating,
    setNote,
    startTimer,
    getTimeRemaining,
    saveSession,
    getHistory,
    resetConstraints
  };
})();

  </script>
  <script>
/**
 * draw.js — Constraint Draw Engine
 * 
 * Responsible for selecting constraints from pools.
 * Uses Fisher-Yates shuffle internally.
 * Stateless: receives a pool, returns a single item.
 * Does not modify the pool or touch State directly.
 */

const Draw = (() => {

  /**
   * Fisher-Yates shuffle on a copy of the array.
   * Returns a new array. Original is untouched.
   */
  function _shuffle(array) {
    const arr = [...array];
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  /**
   * Draw one item from a pool.
   * Optionally exclude items by id (for avoiding repeats).
   * Returns a single constraint object, or null if the pool is empty.
   */
  function one(pool, excludeIds = []) {
    const eligible = pool.filter(item => !excludeIds.includes(item.id));
    if (eligible.length === 0) return null;
    const shuffled = _shuffle(eligible);
    return shuffled[0];
  }

  return { one };
})();

  </script>
  <script>
/**
 * log.js — Session Log Generator
 * 
 * Produces a structured, plain-text ritual log from session state.
 * Used for both on-screen display and clipboard sharing.
 * Pure function. No side effects.
 */

const Log = (() => {

  /**
   * Formats a timestamp into a readable date string.
   */
  function _formatDate(timestamp) {
    if (!timestamp) return '—';
    const d = new Date(timestamp);
    const year  = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day   = String(d.getDate()).padStart(2, '0');
    const hours = String(d.getHours()).padStart(2, '0');
    const mins  = String(d.getMinutes()).padStart(2, '0');
    return `${year}-${month}-${day} ${hours}:${mins}`;
  }

  /**
   * Generates the full session log text.
   * @param {object} state — the current application state snapshot
   * @returns {string} formatted log
   */
  function generate(state) {
    const s = state.structure || {};
    const c = state.constraint || {};
    const ch = state.chaos || {};
    const cType = state.constraintType || '—';
    const rating = state.session.frictionRating || '—';
    const note = state.session.note || '—';
    const date = _formatDate(state.session.startedAt);

    const lines = [
      '─────────────────────────',
      'SONGFORGE',
      'The Book of Maledictions',
      '─────────────────────────',
      '',
      `Date     : ${date}`,
      `Duration : 60 minutes`,
      '',
      '─── I. Structure ─────────',
      `${s.title || '—'}`,
      `${s.description || ''}`,
      '',
      `─── II. ${cType.charAt(0).toUpperCase() + cType.slice(1)} ──────────────`,
      `${c.title || '—'}`,
      `${c.description || ''}`,
      '',
      '─── III. Chaos ───────────',
      `${ch.title || '—'}`,
      `${ch.description || ''}`,
      '',
      '─────────────────────────',
      `Friction : ${rating} / 10`,
      `Note     : ${note}`,
      '─────────────────────────'
    ];

    return lines.join('\n');
  }

  return { generate };
})();

  </script>
  <script>
/**
 * ui.js — UI Renderer
 * 
 * The only module that touches the DOM.
 * Subscribes to State. On every change, renders the correct phase.
 * All text comes from State.strings (i18n-ready).
 * All event handlers are bound here and delegate to State or other modules.
 */

const UI = (() => {
  const root = document.getElementById('app');

  // ─── Helpers ──────────────────────────────────────────

  function t(key) {
    // Dot-notation string lookup: "onboarding.begin_button"
    return key.split('.').reduce((obj, k) => (obj || {})[k], State.get('strings')) || key;
  }

  function clearRoot() {
    root.innerHTML = '';
  }

  function setBodyClass(className) {
    document.body.className = className;
  }

  // ─── Phase Renderers ──────────────────────────────────

  function renderOnboarding() {
    setBodyClass('phase-onboarding');
    root.innerHTML = `
      <div class="screen screen-onboarding">
        <div class="onboarding-inner">
          <h1 class="title">${t('app.title')}</h1>
          <p class="subtitle">${t('app.subtitle')}</p>
          <div class="divider"></div>
          <div class="warning-block">
            <p class="warning-header">${t('onboarding.warning_header')}</p>
            <p class="warning-text">${t('onboarding.warning_text')}</p>
          </div>
          <button class="btn-ritual" id="btn-begin">${t('onboarding.begin_button')}</button>
        </div>
      </div>
    `;

    document.getElementById('btn-begin').addEventListener('click', () => {
      State.resetConstraints();
      State.setPhase('draw_structure');
    });
  }

  function renderDrawStructure() {
    setBodyClass('phase-draw');
    
    // Only draw if we haven't drawn yet
    let drawn = State.get('structure');
    if (!drawn) {
      drawn = Draw.one(State.get('data').structures);
      State.setStructure(drawn);
      return; // Exit and let the state change trigger a re-render
    }

    root.innerHTML = `
      <div class="screen screen-draw">
        <div class="draw-inner">
          <div class="draw-step">
            <span class="step-number">${t('draw.structure_header')}</span>
            <span class="step-label">${t('draw.structure_label')}</span>
          </div>
          <div class="constraint-card" id="card-structure">
            <h2 class="card-title">${drawn.title}</h2>
            <p class="card-desc">${drawn.description}</p>
          </div>
          <button class="btn-ritual" id="btn-accept-structure">${t('draw.accept_structure')}</button>
        </div>
      </div>
    `;

    document.getElementById('btn-accept-structure').addEventListener('click', () => {
      State.setPhase('choice');
    });
  }

  function renderChoice() {
    setBodyClass('phase-choice');
    root.innerHTML = `
      <div class="screen screen-choice">
        <div class="choice-inner">
          <div class="draw-step">
            <span class="step-number">${t('draw.choice_header')}</span>
            <span class="step-label">${t('draw.choice_label')}</span>
          </div>
          <div class="choice-buttons">
            <button class="btn-choice" id="btn-rhythm">${t('draw.choose_rhythm')}</button>
            <button class="btn-choice" id="btn-texture">${t('draw.choose_texture')}</button>
          </div>
        </div>
      </div>
    `;

    document.getElementById('btn-rhythm').addEventListener('click', () => {
      State.setConstraintType('rhythm');
      State.setPhase('draw_constraint');
    });

    document.getElementById('btn-texture').addEventListener('click', () => {
      State.setConstraintType('texture');
      State.setPhase('draw_constraint');
    });
  }

  function renderDrawConstraint() {
    setBodyClass('phase-draw');
    
    // Only draw if we haven't drawn yet
    let drawn = State.get('constraint');
    if (!drawn) {
      const type = State.get('constraintType');
      const pool = type === 'rhythm'
        ? State.get('data').rhythms
        : State.get('data').textures;
      drawn = Draw.one(pool);
      State.setConstraint(drawn);
      return; // Exit and let the state change trigger a re-render
    }

    const type = State.get('constraintType');

    root.innerHTML = `
      <div class="screen screen-draw">
        <div class="draw-inner">
          <div class="draw-step">
            <span class="step-number">${t('draw.choice_header')}</span>
            <span class="step-label">${type.charAt(0).toUpperCase() + type.slice(1)}</span>
          </div>
          <div class="constraint-card" id="card-constraint">
            <h2 class="card-title">${drawn.title}</h2>
            <p class="card-desc">${drawn.description}</p>
          </div>
          <button class="btn-ritual" id="btn-accept-constraint">${t('draw.accept_constraint')}</button>
        </div>
      </div>
    `;

    document.getElementById('btn-accept-constraint').addEventListener('click', () => {
      State.setPhase('draw_chaos');
    });
  }

  function renderDrawChaos() {
    setBodyClass('phase-draw phase-chaos');
    
    // Only draw if we haven't drawn yet
    let drawn = State.get('chaos');
    if (!drawn) {
      drawn = Draw.one(State.get('data').chaos);
      State.setChaos(drawn);
      return; // Exit and let the state change trigger a re-render
    }

    root.innerHTML = `
      <div class="screen screen-draw">
        <div class="draw-inner">
          <div class="draw-step">
            <span class="step-number">${t('draw.chaos_header')}</span>
            <span class="step-label">${t('draw.chaos_label')}</span>
          </div>
          <p class="chaos-warning">${t('draw.chaos_warning')}</p>
          <div class="constraint-card card-chaos" id="card-chaos">
            <h2 class="card-title">${drawn.title}</h2>
            <p class="card-desc">${drawn.description}</p>
          </div>
          <button class="btn-ritual btn-chaos" id="btn-accept-chaos">${t('draw.accept_chaos')}</button>
        </div>
      </div>
    `;

    document.getElementById('btn-accept-chaos').addEventListener('click', () => {
      State.setPhase('recap');
    });
  }

  function renderRecap() {
    setBodyClass('phase-recap');
    const s = State.get('structure');
    const c = State.get('constraint');
    const ch = State.get('chaos');
    const cType = State.get('constraintType');

    root.innerHTML = `
      <div class="screen screen-recap">
        <div class="recap-inner">
          <h2 class="recap-header">${t('recap.header')}</h2>
          <div class="recap-cards">
            <div class="recap-card">
              <span class="recap-card-label">${t('recap.constraint_structure')}</span>
              <h3 class="recap-card-title">${s.title}</h3>
              <p class="recap-card-desc">${s.description}</p>
            </div>
            <div class="recap-card">
              <span class="recap-card-label">${cType.charAt(0).toUpperCase() + cType.slice(1)}</span>
              <h3 class="recap-card-title">${c.title}</h3>
              <p class="recap-card-desc">${c.description}</p>
            </div>
            <div class="recap-card recap-card-chaos">
              <span class="recap-card-label">${t('recap.constraint_chaos')}</span>
              <h3 class="recap-card-title">${ch.title}</h3>
              <p class="recap-card-desc">${ch.description}</p>
            </div>
          </div>
          <button class="btn-ritual" id="btn-begin-session">${t('recap.begin_session')}</button>
        </div>
      </div>
    `;

    document.getElementById('btn-begin-session').addEventListener('click', () => {
      State.startTimer();
    });
  }

  function renderTimer() {
    setBodyClass('phase-timer');
    const remaining = State.get('timer').remaining;
    const mins = String(Math.floor(remaining / 60)).padStart(2, '0');
    const secs = String(remaining % 60).padStart(2, '0');

    // On first render, build the full layout.
    // On subsequent ticks, update only the time text to avoid flicker.
    if (!document.getElementById('timer-display')) {
      root.innerHTML = `
        <div class="screen screen-timer">
          <div class="timer-inner">
            <div class="timer-display" id="timer-display">
              <span class="timer-time" id="timer-time">${mins}:${secs}</span>
              <span class="timer-label">${t('timer.label')}</span>
            </div>
          </div>
        </div>
      `;
    } else {
      document.getElementById('timer-time').textContent = `${mins}:${secs}`;
    }
  }

  function renderEnd() {
    setBodyClass('phase-end');

    // Generate log from current state
    const log = Log.generate(State.getState());

    root.innerHTML = `
      <div class="screen screen-end">
        <div class="end-inner">
          <h2 class="end-header">${t('end.header')}</h2>

          <div class="session-log" id="session-log">
            <pre>${log}</pre>
          </div>

          <div class="friction-block">
            <p class="friction-label">${t('end.friction_label')}</p>
            <p class="friction-sublabel">${t('end.friction_sublabel')}</p>
            <div class="friction-scale" id="friction-scale">
              ${[1,2,3,4,5,6,7,8,9,10].map(n =>
                `<button class="friction-btn" data-value="${n}">${n}</button>`
              ).join('')}
            </div>
          </div>

          <div class="note-block">
            <label class="note-label" for="note-input">${t('end.note_label')}</label>
            <input type="text" id="note-input" class="note-input" placeholder="${t('end.note_placeholder')}" autocomplete="off" />
          </div>

          <button class="btn-ritual" id="btn-share">${t('end.share_button')}</button>
          <p class="share-feedback" id="share-feedback"></p>
        </div>
      </div>
    `;

    // Friction scale event
    document.getElementById('friction-scale').addEventListener('click', (e) => {
      const btn = e.target.closest('.friction-btn');
      if (!btn) return;

      // Deselect all, select clicked
      document.querySelectorAll('.friction-btn').forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
      State.setFrictionRating(parseInt(btn.dataset.value, 10));

      // Regenerate log after rating is set
      updateLog();
    });

    // Note input event (live update, no debounce needed — it's one field)
    document.getElementById('note-input').addEventListener('input', (e) => {
      State.setNote(e.target.value);
      updateLog();
    });

    // Share button
    document.getElementById('btn-share').addEventListener('click', () => {
      const currentLog = Log.generate(State.getState());
      const feedback = document.getElementById('share-feedback');

      // Save session to history on share
      State.saveSession();

      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(currentLog).then(() => {
          feedback.textContent = t('end.share_copied');
          feedback.classList.add('visible');
          setTimeout(() => feedback.classList.remove('visible'), 2500);
        });
      } else {
        feedback.textContent = t('end.share_unsupported');
        feedback.classList.add('visible');
        setTimeout(() => feedback.classList.remove('visible'), 3000);
      }
    });
  }

  /**
   * Re-renders just the session log pre block without rebuilding the whole screen.
   */
  function updateLog() {
    const logEl = document.querySelector('#session-log pre');
    if (logEl) {
      logEl.textContent = Log.generate(State.getState());
    }
  }

  // ─── Main Render Dispatch ─────────────────────────────

  function render(state) {
    switch (state.phase) {
      case 'onboarding':        renderOnboarding();        break;
      case 'draw_structure':    renderDrawStructure();     break;
      case 'choice':            renderChoice();            break;
      case 'draw_constraint':   renderDrawConstraint();    break;
      case 'draw_chaos':        renderDrawChaos();         break;
      case 'recap':             renderRecap();             break;
      case 'timer':             renderTimer();             break;
      case 'end':               renderEnd();               break;
    }
  }

  // ─── Init ─────────────────────────────────────────────

  function init() {
    State.subscribe(render);
    // Trigger initial render
    render(State.getState());
  }

  return { init };
})();

  </script>
  <script>
(function bootstrap() {
  try {
    function loadInlineJSON(id) {
      const el = document.getElementById(id);
      if (!el) throw new Error('Missing data element: ' + id);
      return JSON.parse(el.textContent);
    }
    State.setStrings(loadInlineJSON('data-strings'));
    State.setData('structures', loadInlineJSON('data-structures'));
    State.setData('rhythms',    loadInlineJSON('data-rhythms'));
    State.setData('textures',   loadInlineJSON('data-textures'));
    State.setData('chaos',      loadInlineJSON('data-chaos'));
    UI.init();
  } catch (err) {
    document.getElementById('app').innerHTML =
      '<div style="color:#fff;font-family:monospace;padding:40px;max-width:600px;margin:0 auto">' +
      '<p style="color:#e44">Failed to initialize Songforge.</p>' +
      '<pre style="color:#888;white-space:pre-wrap">' + (err.stack || err.message) + '</pre>' +
      '</div>';
  }
})();
  </script>
</body>
</html>
